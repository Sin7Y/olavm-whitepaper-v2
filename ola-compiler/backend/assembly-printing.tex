\subsubsection{Assembly printing}

Program basic format\par
The basic format of the Ola assembly language is as follows:
\begin{lstlisting}[language={}]
{symbol} {instruction | directive | pseudo-instruction} {; | // comment}
\end{lstlisting}

\begin{itemize}
    \item Symbol indicates a symbol, which must start at the beginning of the line.\par
    \item Instruction indicates an instruction, usually preceded by two spaces.\par
    \item Directive indicates a pseudo operation.\par
    \item Pseudo instruction means a pseudo instruction.\par
    \item Directives, pseudo operations, and pseudo instruction helpers are all case-sensitive, but cannot be mixed.
\end{itemize}

Assembly instructions\par

For simplicity, pseudo operations and pseudo instructions like .global main are not considered for now.\par

Function entries that start with funcName: and end with: are treated as labels. For example, main: defines a label for a function named main.

Note: The symbols that usually start with. symbols that begin with. indicate pseudo directives or pseudo operations, such as different segments. Symbols ending with: indicate labels, such as function names and BB block numbers.

Instruction Format\par
The format of the internal assembly instruction is in the form of a three-address code:
\begin{lstlisting}[language={}]
    <opcode> <Rd> <Rn> <shifter_operand>
\end{lstlisting}

\begin{itemize}
    \item Opcode indicates the instruction helper, usually the instruction helper defined by olavm.\par
    \item Rd indicates the instruction operation destination register, which is usually the register defined by olavm.\par
    \item Rn indicates the first source operand of the instruction, usually a register defined by olavm.\par
    \item shifter operand indicates the instruction data processing operand, usually an immediate or olavm-defined register.
\end{itemize}

Memory layout\par
Instruction address and memory space share the same space.

After the program is loaded, pc points to the zero address and the function stack is switched according to the hierarchy of function calls, 
and the memory address stack grows from a low address to -> high address.