\subsubsection{Note Commitments and Nullifiers}\label{section: commitments-nullifiers}

When each note is created, a corresponding note commitment is generated, and the note commitment promises the validity of all parameters in the note.
$$note\_commitment = Commit(note)$$

Note commitments and notes have a one-to-one bijection relationship, that is, there are no two different notes with the same note commitment, and vice versa. Unlike the account model, there is not a Merkle tree on the chain to store all states, but the ciphertext of notes is scattered among transactions in all blocks, and sequencers only maintain a notes commitment tree. When creating a note, users need to prove that the note commitment of this new note is on the current merkle tree through a zero-knowledge proof.

Every note has a nullifier, generated by the nullifier key and note commitment. In addition to the note commitment tree, sequencers also maintain a nullifier set. When a note is spent, the nullifier of the note needs to be revealed publicly. The node needs to check that the nullifier is not added to the nullifier set, otherwise it will cause the double spending problem.
$$nullifier = Hash(nullifier\_key || note\_commitment)$$