\subsubsection{Ola Compiler Backend}

The backend of the Ola compiler compile ir into target assembly code. It takes the llvm std ir generated by the frontend as input and the  ola assembly code as output.

Its pipeline process is as follow:
\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{ola-lang-backend.jpg}
    \caption{ola-lang backend pipeline}
    \label{fig:ola-lang-backend}
\end{figure}

An example ola-lang ola assembly code for computing sqrt of type u32 with prophet version is as follows:
\begin{lstlisting}[language={}]
{
  "program": "u32_sqrt:\n.LBL3_0:\n  mov r3 r1\n  mov r1 r3\n.PROPHET3_0:\n  mov r0 psp\n  mload r0 [r0,0]\n  range r0\n  mul r2 r0 r0\n  assert r2 r3\n  ret\nmain:\n.LBL4_0:\n  add r8 r8 4\n  mstore [r8,-2] r8\n  mov r1 4\n  call sqrt_test\n  add r8 r8 -4\n  end\nsqrt_test:\n.LBL5_0:\n  add r8 r8 6\n  mstore [r8,-2] r8\n  mov r0 r1\n  mstore [r8,-3] r0\n  mload r1 [r8,-3]\n  call u32_sqrt\n  mstore [r8,-4] r0\n  mload r0 [r8,-4]\n  add r8 r8 -6\n  ret\n",
  "prophets": [
    {
      "label": ".PROPHET3_0",
      "code": "%{\n    entry() {\n        cid.y = sqrt(cid.x);\n    }\n%}",
      "inputs": [
        "cid.x"
      ],
      "outputs": [
        "cid.y"
      ]
    }
  ]
}
\end{lstlisting}

An example ola-lang ola assembly code for computing sqrt of type u32 with instructions version is as follows:
\begin{lstlisting}[language={}]
{
  "program": "main:\n.LBL5_0:\n  add r8 r8 4\n  mstore [r8,-2] r8\n  mov r1 4\n  call sqrt_test\n  add r8 r8 -4\n  end\nsqrt_test:\n.LBL6_0:\n  add r8 r8 19\n  mstore [r8,-16] r1\n  mov r1 0\n  mstore [r8,-17] r1\n  mload r1 [r8,-16]\n  gte r2 r1 3\n  neq r0 r1 3\n  and r2 r2 r0\n  cjmp r2 .LBL6_1\n  jmp .LBL6_2\n.LBL6_1:\n  mload r0 [r8,-16]\n  mstore [r8,-17] r0\n  mload r0 [r8,-16]\n  mstore [r8,-12] r0\n  mload r0 [r8,-12]\n  mov r1 r0\n  mov r2 2\n.PROPHET6_0:\n  mov r0 psp\n  mload r0 [r0,0]\n  mstore [r8,-11] r0\n  mload r0 [r8,-11]\n  range r0\n  mov r0 2\n  mload r1 [r8,-11]\n  add r4 r1 1\n  not r7 r4\n  add r7 r7 1\n  add r5 r0 r7\n  range r5\n  mload r0 [r8,-12]\n  mov r1 r0\n  mov r2 2\n.PROPHET6_1:\n  mov r0 psp\n  mload r0 [r0,0]\n  range r0\n  mul r1 r0 2\n  mstore [r8,-15] r1\n  mload r1 [r8,-15]\n  mload r2 [r8,-11]\n  add r1 r1 r2\n  mstore [r8,-14] r1\n  mload r1 [r8,-14]\n  mload r2 [r8,-12]\n  assert r1 r2\n  add r0 r0 1\n  mstore [r8,-13] r0\n  mload r0 [r8,-13]\n  range r0\n  mload r0 [r8,-13]\n  mstore [r8,-18] r0\n  mov r0 0\n  mstore [r8,-19] r0\n  jmp .LBL6_4\n.LBL6_2:\n  mload r0 [r8,-16]\n  neq r0 r0 0\n  cjmp r0 .LBL6_10\n  jmp .LBL6_11\n.LBL6_3:\n  mload r0 [r8,-17]\n  add r8 r8 -19\n  ret\n.LBL6_4:\n  mload r0 [r8,-19]\n  mov r1 100\n  gte r1 r1 r0\n  neq r3 r0 100\n  and r1 r1 r3\n  cjmp r1 .LBL6_5\n  jmp .LBL6_7\n.LBL6_5:\n  mload r0 [r8,-18]\n  mload r1 [r8,-17]\n  gte r0 r0 r1\n  cjmp r0 .LBL6_8\n  jmp .LBL6_9\n.LBL6_6:\n  mload r1 [r8,-19]\n  add r0 r1 1\n  mstore [r8,-19] r0\n  jmp .LBL6_4\n.LBL6_7:\n  jmp .LBL6_3\n.LBL6_8:\n  jmp .LBL6_7\n.LBL6_9:\n  mload r0 [r8,-18]\n  mstore [r8,-17] r0\n  mload r0 [r8,-16]\n  mstore [r8,-3] r0\n  mload r0 [r8,-18]\n  mstore [r8,-2] r0\n  mload r0 [r8,-3]\n  mov r1 r0\n  mload r0 [r8,-2]\n  mov r2 r0\n.PROPHET6_2:\n  mov r0 psp\n  mload r0 [r0,0]\n  mstore [r8,-1] r0\n  mload r0 [r8,-1]\n  range r0\n  mload r0 [r8,-1]\n  add r4 r0 1\n  not r7 r4\n  add r7 r7 1\n  mload r0 [r8,-2]\n  add r5 r0 r7\n  range r5\n  mload r0 [r8,-3]\n  mov r1 r0\n  mload r0 [r8,-2]\n  mov r2 r0\n.PROPHET6_3:\n  mov r0 psp\n  mload r0 [r0,0]\n  range r0\n  mload r1 [r8,-2]\n  mul r1 r0 r1\n  mstore [r8,-10] r1\n  mload r1 [r8,-10]\n  mload r2 [r8,-1]\n  add r1 r1 r2\n  mstore [r8,-9] r1\n  mload r1 [r8,-9]\n  mload r2 [r8,-3]\n  assert r1 r2\n  mload r1 [r8,-18]\n  add r0 r0 r1\n  mstore [r8,-5] r0\n  mload r0 [r8,-5]\n  range r0\n  mload r0 [r8,-5]\n  mov r1 r0\n  mov r2 2\n.PROPHET6_4:\n  mov r0 psp\n  mload r0 [r0,0]\n  mov r4 r0\n  range r4\n  mov r0 2\n  add r1 r4 1\n  mstore [r8,-8] r1\n  mload r1 [r8,-8]\n  not r7 r1\n  add r7 r7 1\n  add r0 r0 r7\n  mstore [r8,-7] r0\n  mload r0 [r8,-7]\n  range r0\n  mload r0 [r8,-5]\n  mov r1 r0\n  mov r2 2\n.PROPHET6_5:\n  mov r0 psp\n  mload r0 [r0,0]\n  range r0\n  mul r1 r0 2\n  mstore [r8,-6] r1\n  mload r1 [r8,-6]\n  add r1 r1 r4\n  mstore [r8,-4] r1\n  mload r1 [r8,-5]\n  mload r2 [r8,-4]\n  assert r2 r1\n  mstore [r8,-18] r0\n  jmp .LBL6_6\n.LBL6_10:\n  mov r0 1\n  mstore [r8,-17] r0\n  jmp .LBL6_11\n.LBL6_11:\n  jmp .LBL6_3\n",
  "prophets": [
    {
      "label": ".PROPHET6_0",
      "code": "%{\n    function mod(felt x, felt y) -> felt {\n        return x % y;\n    }\n    entry() {\n        cid.r = mod(cid.x, cid.y);\n    }\n%}",
      "inputs": [
        "cid.x",
        "cid.y"
      ],
      "outputs": [
        "cid.r"
      ]
    },
    {
      "label": ".PROPHET6_1",
      "code": "%{\n    function div(felt x, felt y) -> felt {\n        return x / y;\n    }\n    entry() {\n        cid.q = div(cid.x, cid.y);\n    }\n%}",
      "inputs": [
        "cid.x",
        "cid.y"
      ],
      "outputs": [
        "cid.q"
      ]
    },
    {
      "label": ".PROPHET6_2",
      "code": "%{\n    function mod(felt x, felt y) -> felt {\n        return x % y;\n    }\n    entry() {\n        cid.r = mod(cid.x, cid.y);\n    }\n%}",
      "inputs": [
        "cid.x",
        "cid.y"
      ],
      "outputs": [
        "cid.r"
      ]
    },
    {
      "label": ".PROPHET6_3",
      "code": "%{\n    function div(felt x, felt y) -> felt {\n        return x / y;\n    }\n    entry() {\n        cid.q = div(cid.x, cid.y);\n    }\n%}",
      "inputs": [
        "cid.x",
        "cid.y"
      ],
      "outputs": [
        "cid.q"
      ]
    },
    {
      "label": ".PROPHET6_4",
      "code": "%{\n    function mod(felt x, felt y) -> felt {\n        return x % y;\n    }\n    entry() {\n        cid.r = mod(cid.x, cid.y);\n    }\n%}",
      "inputs": [
        "cid.x",
        "cid.y"
      ],
      "outputs": [
        "cid.r"
      ]
    },
    {
      "label": ".PROPHET6_5",
      "code": "%{\n    function div(felt x, felt y) -> felt {\n        return x / y;\n    }\n    entry() {\n        cid.q = div(cid.x, cid.y);\n    }\n%}",
      "inputs": [
        "cid.x",
        "cid.y"
      ],
      "outputs": [
        "cid.q"
      ]
    }
  ]
}
\end{lstlisting}

The backend data structure contains mainly lists,insts and mcinsts. The ABI then contains Function call specification and Mapping Relationships to Virtual Memory.

The backend codegen pipeline process:
\begin{itemize}
    \item IR parsing

    \item Function call lowering

    \item Instruction selection

    \item Register Allocation

    \item Slot elimination

    \item Stack frame handling

    \item Assembly printing
\end{itemize}

The detailed process is as follows:
    \begin{itemize}
        \item IR parsing

IR is composed of the following structure: module -> function -> value -> types.

(1) Module structure contains Target (triple and datalayout information), Function, Attribute, GlobalVariable.

(2) Function structure contains name, type information, Visibility, Attribute and Parameter list basic information, and data, Layout.

(3) Among them, layout contains the sequential logical relationship between basicBlocks and the instructions within them.

(4) Data contains the specific Value, Instruction, BasicBlock list instances.

(5) BasicBlock is identified by BasicBlockId and consists of two parts: name and number. Each BB block usually contains one preds and one sucs.

(6) Instruction is identified by BasicBlockId+InstructionId and usually consists of Opcode, Operand, dest and the Type of its operation.

(7) Value contains Instruction, Argument, Constant and InlineAsm types.

(8) Due to the characteristics of the instruction set of olavm, the type is currently mainly i64 type.

        \item IR parsing process

process: targetDatalayout/targetTriple -> attributeGroup -> localType -> globalVariable -> function -> metadata.

The function is mainly divided into two parts: parseArgumentList and parseBody.

Its pipeline process is as follow:
\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{ola-lang-backend-parser.jpg}
    \caption{ola-lang backend parser pipeline}
    \label{fig:ola-lang-backend-parser}
\end{figure}

        \item IR opt pass

Pre-analysis analysis pass is mainly DominatorTree, conversion transform pass contains dce, mem2reg, sccp.

Its pipeline process is as follow:
\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{ola-lang-backend-ir-opt.jpg}
    \caption{ola-lang backend ir opt}
    \label{fig:ola-lang-backend-ir-opt}
\end{figure}

        \item back-end codegen modules

bridging ir structure of module, function, and isa related callconv, register and isa, code generation related lower and optimization related pass.

TargetISA main contains custom TargetInst, Register(RegisterClass/RegisterInfo), lower and modulepasses, callconv, datalayout information.

Module in addition to inheritance Ir parsed out Module, the description of its Function and ir differ significantly.

Data information: BasicBlock in the instructions for Target Instruction, register contains VRegs and RegUnit two categories, and contains a vregtoinsts mapping.
At the same time, Inst in Layout are referred to TargetInst. Note that the memory access operations of parameters, local variables, etc. are described by the structure of slot(ptr+offset).

The lower module provides the process of downgrading LoweringContext to Instruction, and for function calls it also requires copyargstovregs.

The pass module contains the regalloc and spiller for analyzing the liveness of the pass and the function pass.

        \item back-end process

(1) Register and insts description

Register description is as below:
\begin{table}[!ht]
    \resizebox{\textwidth}{!}{
        \begin{tabular}{|c|c|c|}
            \hline
            \textit{Type}  & \textit{Description} & \textit{Register Group}  \\ \hline
            general registers & general used by program &  $[r0-r8] $ \\ \hline
            return regsiter & return value for return to caller &  $[r0] $ \\ \hline
            parameters rigsters & parameters value for passing arguments &  $ [r1, r2, r3] $ \\ \hline
            tmp registers & tmp alloc for local variables &  $[r4, r5, r6, r7]$ \\ \hline
            stack pointer & function's stack pointer &  $[r8] $ \\ \hline
            special registers & interact with vm: pc for program counter and psp for prophet pointer &   $[pc, psp] $ \\ \hline
        \end{tabular}}
    \caption{Register Description}
    \label{table:register-description}
\end{table}

Insts description is as bellow:

Opcode with register or immdiate number:
\begin{lstlisting}[language={}]
    ADDri,
    ADDrr,
    MULri,
    MULrr,

    EQri,
    EQrr,
    ASSERTri,
    ASSERTrr,

    MOVri,
    MOVrr,

    JMPi,
    JMPr,
    CJMPi,
    CJMPr,
    CALL,
    RET,
    END,

    MLOADi,
    MLOADr,
    MSTOREi,
    MSTOREr,

    RANGECHECK,
    AND,
    OR,
    XOR,
    NOT,
    NEQ,
    GTE,

    PROPHET,

    Phi,
\end{lstlisting}

Operand data type:
\begin{lstlisting}[language={}]
    Reg(Reg),
    VReg(VReg),
    Int8(i8),
    Int32(i32),
    Int64(i64),
    MemStart,
    Slot(SlotId),
    Block(BasicBlockId),
    Label(String),
    GlobalAddress(String),
    None,
\end{lstlisting}


(2) Function call lower
    
Procedure Call Conventions as follow:

Initialization points to the first address of frame stack after the \texttt{[fp]} register is loaded.
    
The address will be increased when the \texttt{[call]}  instruction is executed later. When the \texttt{[ret]} instruction is executed, the \texttt{[fp]} register points to the address and falls back.
    
    
the Calling Process is as follow:
    Use  \texttt{[call]} to call function, and \texttt{[fp]} points to the new frame.\par
    (a) The \texttt{[pc]} address returned by the function is placed in \texttt{[fp-1]}.\par
    (b) The address pointed to by fp before the function call is placed in  \texttt{[fp-2]}.\par
    (c) Function parameter processing: the first four input parameters are placed in the four registers \texttt{[r0]}, \texttt{[r1]}, \texttt{[r2]}, and \texttt{[r3]}. If there are more than 4 parameters, start with the fifth input parameter and descend accordingly in \texttt{[fp-3]} , \texttt{[fp-4]} , â‹¯. \par
    (d) Local variables inside the function start at \texttt{[fp]}, and the \texttt{[fp]} address is stored incrementally. The return value is stored in \texttt{[r0]}. If the return value is not a domain element, it needs to be returned by a memory pointer that returns the data.\par
    
(3) Instruction selection

It match ir insts opcode + operand pattern, then lower the matched pattern to target machine code insts.

Several common patterns such as: 
\begin{table}[!ht]
    \resizebox{\textwidth}{!}{
        \begin{tabular}{|c|c|}
            \hline
            \textit{Pattern Type} & \textit{Description} \\ \hline
            Alloca  & params and vars allocation \\ \hline
            IntBinary & bianary operator \\ \hline
            Load & memory load \\ \hline
            Store & memory store  \\ \hline
            Call & function call \\ \hline
            Return & function call return \\ \hline
            Branch & branch control flow \\ \hline
            Conditional Branch & conditional branch control flow \\ \hline
        \end{tabular}}
    \caption{Instruction pattern}
    \label{table:Instruction-pattern}
\end{table}

Let's take Conditional Branch for example, it's target insts as follow:
\begin{table}[!ht]
    \resizebox{\textwidth}{!}{
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textit{operator}  & \textit{Reg+Imm} & \textit{Reg+Reg} & \textit{Cycles}  \\ \hline
            == & Mov tmpReg imm; \par Eq  tmpReg regA tmpReg; \par Cjmp regA labelTrue & Eq  tmpReg regA regB;\par Cjmp tmpReg labelTrue & 2inst + 2reg; 1inst + 3reg \\ \hline
            <  & Mov tmpReg imm; lt  tmpReg regA tmpReg; Cjmp regA labelTrue & lt  tmpReg regA regB; Cjmp tmpReg labelTrue & 2inst + 2reg; 1inst + 3reg \\ \hline
            <= &  &   &  \\ \hline
            >  &  &   &  \\ \hline
            >= &  &   &  \\ \hline
            != &  &   &  \\ \hline
        \end{tabular}}
    \caption{Register Description}
    \label{table:register-description}
\end{table}

(4) Slot elimination

This pass handle the stack slot for local variables.

Its pipeline as follow:
\begin{lstlisting}[language={}]
VistModule
    | VisitFunction layout
        | VisitBasicBlock
            | Match inst's data operand is Slot type
                | workList: push inst 
    | computer slot offset
    | foreach workList
        | fixup inst's operand with offset and size
\end{lstlisting}

(5) prologue and epilogue insertion

When the processing is completed after the parameters of the function and the function body, 
as part of the function it need to do the corresponding stack space processing at the entrance and exit, respectively. 
That is, first calculate the stack size, then the stack is opened at the entrance, and the stack is recycled at the exit.

when no function call, entrance is 1 add inst:
\begin{lstlisting}[language={}]
    InstructionData {
        opcode: Opcode::ADDri,
        operands: vec![
            Operand::input_output(GR::R8.into()),
            Operand::input_output(GR::R8.into()),
            Operand::input(adj.into()),
        ],
    }
\end{lstlisting}

when function call, entrance is  1 add inst and 1 mstore inst:
\begin{lstlisting}[language={}]
    InstructionData {
        opcode: Opcode::ADDri,
        operands: vec![
            Operand::input_output(GR::R8.into()),
            Operand::input_output(GR::R8.into()),
            Operand::input(adj.into()),
        ],
    }

    InstructionData {
        opcode: Opcode::MSTOREr,
        operands: vec![
            Operand::output(GR::R8.into()),
            Operand::input(GR::R8.into()),
        ],
    }
\end{lstlisting}

exit is 1 sub operator which is expressed as add inst:
\begin{lstlisting}[language={}]
    InstructionData {
        opcode: Opcode::ADDri,
        operands: vec![
            Operand::output(GR::R8.into()),
            Operand::input_output(GR::R8.into()),
            Operand::input((-adj).into()),
        ],
    }
\end{lstlisting}


(6) register allocation and coalescing

register allocation use linear scan method:\par
(a) Analyze liveness in function, for input and output find live in and live out.\par
(b) Insert spill and reload code, push to worklist\par
(c) Rewrite virtual register for target register.

register coalescing pile line:

(a) Foreach the movrr MCInst at basicblock of function on module.\par
(b) If two register is same, then push it into worklist.\par
(c) Remove the inst in worklis from function.\par

(7) Assembly printing

Program basic format\par
The basic format of ola assembly language is as follows:
\begin{lstlisting}[language={}]
{symbol} {instruction | directive | pseudo-instruction} {; | // comment}
\end{lstlisting}

Symbol indicates a symbol, which must start at the beginning of the line.\par
Instruction indicates an instruction, usually preceded by two spaces.\par
Directive indicates a pseudo-operation.\par
Pseudo-instruction means a pseudo instruction.\par
Directives, pseudo-operations, and pseudo-instruction helpers are all case-sensitive, but cannot be mixed.\apr

Assembly instructions
For simplicity, pseudo-operations and pseudo-instructions like .global main are not considered for now.\par

Function entries that start with funcName: and end with : are treated as labels. For example, main: defines a label for a function named main.

Note: The symbols that usually start with . symbols that begin with . indicate pseudo directives or pseudo operations, such as different segments. Symbols ending with : indicate labels, such as function names and BB block numbers.

Instruction Format\par
The format of the internal assembly instruction is in the form of a three-address code: 
\begin{lstlisting}[language={}]
    <opcode> <Rd> <Rn> <shifter_operand>
\end{lstlisting}

Opcode indicates the instruction helper, usually the instruction helper defined by olavm.\par
Rd indicates the instruction operation destination register, which is usually the register defined by olavm.\par
Rn indicates the first source operand of the instruction, usually a register defined by olavm.\par
shifter operand indicates the instruction data processing operand, usually an immediate or olavm-defined register.

Memory layout\par
Instruction address and memory space share the same space.

After the program is loaded, pc points to zero address, and the function stack is switched according to the hierarchy of function calls, 
and the memory address stack grows from low address -> high address.
    \end{itemize}