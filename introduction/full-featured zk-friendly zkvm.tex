\subsection{Full-featured ZK-friendly ZKVM}

As mentioned earlier, the best way to achieve programmability is to design a ZKVM with a custom Instruction Set Architecture, a custom smart contract language, and a custom compilation, etc. 
ZKVM is a virtual machine that can execute any program and at the same time generate a zero-knowledge proof of the correctness of the execution process. Therefore, the speed of proof generation 
is very critical, and it will directly affect the performance of the entire system.

The key to obtaining a full-featured zk-friendly ZKVM is how to obtain(1)the smallest execution trajectory; (2)the most concise state transition constraint logic; (3)the fastest 
zero-knowledge proof algorithm. The smallest execution trajectory means: for the same computational logic, OlaVM \cite{website:OlaVM} can be expressed with the least instructions, the main technical means are the 
support for non-deterministic computation at the computational level, and the register-based design is used at the memory access level; The most concise state transition constraint logic means: 
for the same computational logic, OlaVM \cite{website:OlaVM} can constrain the entire execution trajectory with the least polynomials and the smallest order. The main means is to obtain the instruction with the least 
number of instructions through the Algebraic RISC architecture. The number of Instruction Set Architecture determines the complexity of Cpu constraints; faster zero-knowledge proof algorithm 
Meaning: For the same calculation, OlaVM \cite{website:OlaVM} can complete the proof generation process in less time, which mainly depends on the Godilocks \cite{website:Goldilocks} field, a finite field less than 64bit, compared to the 
SNARK system based on large bit width elements of elliptic curves, based on The STARK algorithm of the Goldilocks \cite{website:Goldilocks} field can be executed faster.

Subsequent chapters will explain in detail Ola's design philosophy and design specifications for obtaining a Full-featured ZK-friendly ZKVM. As the first programmable privacy layer network 
based on ZKVM, Ola will support the following scenarios for different subjects:

\begin{itemize}
\item For Developers
    \begin{itemize}
    \item Developers can freely choose to deploy public contracts(Account-based), privacy contracts(Note-based), and ordinary contracts(Account and Note-based)
        \begin{enumerate}
        \item For public contracts, Ola functions as a ZKVM;
        \item For privacy contracts, Ola functions as a ZK-ZKVM;
        \item For ordinary contracts, Ola functions as a ZK-ZKVM or ZKVM, depending on the user's transaction type;
        \end{enumerate}
    \item Transfer of assets between public and private accounts
    \item Intra-contract, no bridge contract is required, supported by default;
    \item Cross-contract, a bridge contract is required;
    \end{itemize}
\item For Users
    \begin{itemize}
    \item For ordinary contract types, users can freely choose the transaction type;
    \item For public/private contract types, users can only execute transactions of the corresponding type;
    \item Users have a view key to disclose executed private transactions;
    \item Ola supports the update of the view key so that after the view key is exposed, the privacy transactions executed by the user in the future will always be parsed;
    \item Ola supports asset transfers between public and private accounts;
    \end{itemize}
\end{itemize}