\subsection{Full-featured ZK-friendly ZKVM}

To achieve programmability, the optimal approach is to create a complete zk-friendly ZKVM with a customized instruction set, smart contract language, compiler, and more. A ZKVM is a virtual machine capable of executing any program while simultaneously generating a zero-knowledge proof of the correctness of the execution process. Therefore, the speed of proof generation is crucial, as it directly affects the system's performance.

The key to obtaining a full-featured zk-friendly ZKVM lies in obtaining (
\begin{enumerate}
    \item The smallest possible execution trace
    \item The most succinct state transition constraints
    \item The fastest zero-knowledge proof algorithm
\end{enumerate}

The smallest execution trace refers to the ability of OlaVM \cite{website:OlaVM} to use the fewer instructions for the same computational logic, achieved through non-deterministic computation support at the computational level and register-based design at the memory access level. 

The most succinct state transition constraints refer to the ability to constrain the entire execution trace of OlaVM for the same computational logic with the fewest polynomials and the smallest order, accomplished through Algebraic RISC architecture. The instruction sets size determines the CPU circuits complexity. 

A faster zero-knowledge proof algorithm refers to the ability to complete the proof generation process in a shorter time for the same calculation using OlaVM. This primarily depends on the Goldilocks \cite{website:Goldilocks} field, a finite field less than 64-bit. Compared to the SNARK system based on large bit-width elements of elliptic curves, the STARK algorithm based on the Goldilocks \cite{website:Goldilocks} field is executed faster.

The subsequent chapters will elaborate on Ola's design philosophy and specifications for obtaining a full-featured zk-friendly ZKVM. Ola, a programmable privacy Layer2 network based on ZKVM, Ola will support the following features and use cases: 

\begin{itemize}
\item Projects:
    \begin{itemize}
    \item Developers can freely choose to deploy public contracts (Account-based), privacy contracts (Note-based), and ordinary contracts (Account and Note-based).
        \begin{enumerate}
        \item For public contracts, Ola functions as a ZKVM;
        \item For privacy contracts, Ola functions as a ZK-ZKVM;
        \item For ordinary contracts, Ola functions as a ZK-ZKVM or ZKVM, depending on the user's transaction type;
        \end{enumerate}
    \item Transfer of assets between public and private accounts
    \item Intra-contract, no bridge contract is required, supported by default;
    \item Cross-contract, a bridge contract is required;
    \end{itemize}
\item Users:
    \begin{itemize}
    \item For ordinary contract types, users can freely choose the transaction type;
    \item For public/private contract types, users can only execute transactions of the corresponding type;
    \item Users have a view key to disclose executed private transactions;
    \item Ola supports the update of the view key so that after the view key is exposed, the privacy transactions executed by the user in the future will always be parsed;
    \item Ola supports asset transfers between public and private accounts.
    \end{itemize}
\end{itemize}
