\subsection{Full-featured ZK-friendly ZKVM}

As mentioned before, the best way to achieve programmability is to design a full-featured zk-friendly ZKVM with a customized instruction set, a customized smart contract language, a customized compiler, etc. 
ZKVM is a virtual machine that can execute any program and at the same time generate a zero-knowledge proof of the correctness of the execution process. Therefore, the speed of proof generation 
is very critical, and it will directly affect the performance of the entire system.

The key to obtaining a full-featured zk-friendly ZKVM is how to obtain (1) the smallest execution trace; (2) the most succinct state transition constraints; (3) the fastest 
zero-knowledge proof algorithm. The smallest execution trace means: for the same computational logic, OlaVM \cite{website:OlaVM} can be expressed with the least instructions, the main technical means are the 
support for non-deterministic computation at the computational level, and the register-based design is used at the memory access level; The most succinct state transition constraints means: 
for the same computational logic, OlaVM \cite{website:OlaVM} can constrain the entire execution trace with the least polynomials and the smallest order. The main means is to obtain the instruction with the least 
number of instructions through the Algebraic RISC architecture. The size of instruction set determines the complexity of CPU circuit; a faster zero-knowledge proof algorithm 
means: for the same calculation, OlaVM \cite{website:OlaVM} can complete the proof generation process in a smaller time, which mainly depends on the Goldilocks \cite{website:Goldilocks} field, a finite field less than 64bit, compared to the 
SNARK system based on large bit width elements of elliptic curves, the STARK algorithm based on the Goldilocks \cite{website:Goldilocks} field can be executed faster.

Subsequent chapters will explain in detail Ola's design philosophy and design specifications for obtaining a full-featured zk-friendly ZKVM. As a programmable privacy Layer2 network 
based on ZKVM, Ola will support the following scenarios for different subjects:

\begin{itemize}
\item For project side
    \begin{itemize}
    \item Developers can freely choose to deploy public contracts (Account-based), privacy contracts (Note-based), and ordinary contracts (Account and Note-based)
        \begin{enumerate}
        \item For public contracts, Ola functions as a ZKVM;
        \item For privacy contracts, Ola functions as a ZK-ZKVM;
        \item For ordinary contracts, Ola functions as a ZK-ZKVM or ZKVM, depending on the user's transaction type;
        \end{enumerate}
    \item Transfer of assets between public and private accounts
    \item Intra-contract, no bridge contract is required, supported by default;
    \item Cross-contract, a bridge contract is required;
    \end{itemize}
\item For user side
    \begin{itemize}
    \item For ordinary contract types, users can freely choose the transaction type;
    \item For public/private contract types, users can only execute transactions of the corresponding type;
    \item Users have a view key to disclose executed private transactions;
    \item Ola supports the update of the view key so that after the view key is exposed, the privacy transactions executed by the user in the future will always be parsed;
    \item Ola supports asset transfers between public and private accounts;
    \end{itemize}
\end{itemize}
